env1 :: Env
env1 = [("sum",10), ("y",3), ("i",5), ("acc",1),("c",3),("n",2)]
env2 :: Env
env2 = [("sum",20), ("y",100), ("i",5), ("acc",10),("c",4),("n",5)]

testLinesString =
  [ "(lexer \"sum := sum + y;\")"
  , "(lexer \"i := i + 2;\")"
  , "(lexer \"max := 100;\")"
  , "(lexer \"acc := acc * c;\")"
  , "(lexer \"return sum;\")"
  , "(lexer \"if (n==2) then return 1;\")"
  , "(lexer \"if (n % 2 == 0) then return 0;\")"
  , "(lexer \"while c <= fib - 1\")"
  , "(lexer \"while ! (fact <= c) {  c := c+1;   acc := acc * c; }\")"
  , "(lexer \"c:= c+1; z:= x+y; x:=y; y:=z;\")"
  , "(sr [] [VSym \"sum\",AssignOp,VSym \"sum\",BOp AddOp,VSym \"y\",Semi])"
  , "(sr [] [VSym \"i\",AssignOp,VSym \"i\",BOp AddOp,CSym 2,Semi])"
  , "(sr [] [VSym \"max\",AssignOp,CSym 100,Semi])"
  , "(sr [] [VSym \"acc\",AssignOp,VSym \"acc\",BOp MulOp,VSym \"c\",Semi])"
  , "(sr [] [Keyword ReturnK,VSym \"sum\",Semi])"
  , "(sr [] [Keyword IfK,LPar,VSym \"n\",BOp EqOp,CSym 2,RPar,Keyword ThenK,Keyword ReturnK,CSym 1,Semi])"
  , "(sr [] [Keyword IfK,LPar,VSym \"n\",BOp ModOp,CSym 2,BOp EqOp,CSym 0,RPar,Keyword ThenK,Keyword ReturnK,CSym 0,Semi])"
  , "(sr [] [Keyword WhileK,VSym \"c\",BOp LteOp,VSym \"fib\",BOp SubOp,CSym 1])"
  , "(sr [] [Keyword WhileK,NotOp,LPar,VSym \"fact\",BOp LteOp,VSym \"c\",RPar,LBra,VSym \"c\",AssignOp,VSym \"c\",BOp AddOp,CSym 1,Semi,VSym \"acc\",AssignOp,VSym \"acc\",BOp MulOp,VSym \"c\",Semi,RBra])"
  , "(sr [] [VSym \"c\",AssignOp,VSym \"c\",BOp AddOp,CSym 1,Semi,VSym \"z\",AssignOp,VSym \"x\",BOp AddOp,VSym \"y\",Semi,VSym \"x\",AssignOp,VSym \"y\",Semi,VSym \"y\",AssignOp,VSym \"z\",Semi])"
  , "(readProg [VSym \"sum\",AssignOp,VSym \"sum\",BOp AddOp,VSym \"y\",Semi])"
  , "(readProg [VSym \"i\",AssignOp,VSym \"i\",BOp AddOp,CSym 2,Semi])"
  , "(readProg [VSym \"max\",AssignOp,CSym 100,Semi])"
  , "(readProg [VSym \"acc\",AssignOp,VSym \"acc\",BOp MulOp,VSym \"c\",Semi])"
  , "(readProg [Keyword ReturnK,VSym \"sum\",Semi])"
  , "(readProg [Keyword IfK,LPar,VSym \"n\",BOp EqOp,CSym 2,RPar,Keyword ThenK,Keyword ReturnK,CSym 1,Semi])"
  , "(readProg [Keyword IfK,LPar,VSym \"n\",BOp ModOp,CSym 2,BOp EqOp,CSym 0,RPar,Keyword ThenK,Keyword ReturnK,CSym 0,Semi])"
  , "(readProg [Keyword WhileK,VSym \"c\",BOp LteOp,VSym \"fib\",BOp SubOp,CSym 1])"
  , "(readProg [Keyword WhileK,NotOp,LPar,VSym \"fact\",BOp LteOp,VSym \"c\",RPar,LBra,VSym \"c\",AssignOp,VSym \"c\",BOp AddOp,CSym 1,Semi,VSym \"acc\",AssignOp,VSym \"acc\",BOp MulOp,VSym \"c\",Semi,RBra])"
  , "(readProg [VSym \"c\",AssignOp,VSym \"c\",BOp AddOp,CSym 1,Semi,VSym \"z\",AssignOp,VSym \"x\",BOp AddOp,VSym \"y\",Semi,VSym \"x\",AssignOp,VSym \"y\",Semi,VSym \"y\",AssignOp,VSym \"z\",Semi])"
  , "(evala env1 (Add (Var \"sum\") (Var \"y\")))"
  , "(evala env1 (Add (Var \"i\") (Num 2)))"
  , "(evala env1 (Mul (Var \"acc\") (Var \"c\")))"
  , "(evala env1 (Add (Var \"c\") (Num 1)))"
  , "(evala env1 (Mod (Var \"n\") (Num 2)))"
  , "(evala env2 (Add (Var \"sum\") (Var \"y\")))"
  , "(evala env2 (Add (Var \"i\") (Num 2)))"
  , "(evala env2 (Mul (Var \"acc\") (Var \"c\")))"
  , "(evala env2 (Add (Var \"c\") (Num 1)))"
  , "(evala env2 (Mod (Var \"n\") (Num 2)))"
  , "(evalb env1 (Eq (Var \"n\") (Num 2)))"
  , "(evalb env1 (Eq (Mod (Var \"n\") (Num 2)) (Num 0)))"
  , "(evalb env1 (Not (Lte (Var \"sum\") (Var \"c\"))))"
  , "(evalb env1 (Not (Gte (Var \"sum\") (Var \"c\"))))"
  , "(evalb env1 (Lte (Var \"c\") (Sub (Var \"n\") (Num 1))))"
  , "(evalb env2 (Eq (Var \"n\") (Num 2)))"
  , "(evalb env2 (Eq (Mod (Var \"n\") (Num 2)) (Num 0)))"
  , "(evalb env2 (Not (Lte (Var \"sum\") (Var \"c\"))))"
  , "(evalb env2 (Not (Gte (Var \"sum\") (Var \"c\"))))"
  , "(evalb env2 (Lte (Var \"c\") (Sub (Var \"n\") (Num 1))))"
  , "(exec (Assign \"fact\" (Num 5)) [])"
  , "(exec (Assign \"acc\" (Num 1)) [(\"fact\",5)])"
  , "(exec (Assign \"c\" (Num 1)) [(\"fact\",5),(\"acc\",1)])"
  , "(exec (While (Not (Lte (Var \"fact\") (Var \"c\"))) (Do [Assign \"c\" (Add (Var \"c\") (Num 1)),Assign \"acc\" (Mul (Var \"acc\") (Var \"c\"))])) [(\"fact\",5),(\"acc\",1),(\"c\",1)])"
  , "(exec (Return (Var \"acc\")) [(\"fact\",5),(\"acc\",120),(\"c\",5)])"
  , "(execList [Assign \"c\" (Add (Var \"c\") (Num 1)),Assign \"acc\" (Mul (Var \"acc\") (Var \"c\"))] [(\"fact\",5),(\"acc\",1),(\"c\",1)])"
  , "(execList [Assign \"c\" (Add (Var \"c\") (Num 1)),Assign \"acc\" (Mul (Var \"acc\") (Var \"c\"))] [(\"fact\",5),(\"acc\",2),(\"c\",2)])"
  , "(execList [Assign \"c\" (Add (Var \"c\") (Num 1)),Assign \"acc\" (Mul (Var \"acc\") (Var \"c\"))] [(\"fact\",5),(\"acc\",6),(\"c\",3)])"
  , "(execList [Assign \"c\" (Add (Var \"c\") (Num 1)),Assign \"acc\" (Mul (Var \"acc\") (Var \"c\"))] [(\"fact\",5),(\"acc\",24),(\"c\",4)])"
  , "(execList [Assign \"fact\" (Num 5),Assign \"acc\" (Num 1),Assign \"c\" (Num 1),While (Not (Lte (Var \"fact\") (Var \"c\"))) (Do [Assign \"c\" (Add (Var \"c\") (Num 1)),Assign \"acc\" (Mul (Var \"acc\") (Var \"c\"))]),Return (Var \"acc\")] [])"
  ]

tests =
  [ ((lexer "sum := sum + y;") == [VSym "sum",AssignOp,VSym "sum",BOp AddOp,VSym "y",Semi])
  , ((lexer "i := i + 2;") == [VSym "i",AssignOp,VSym "i",BOp AddOp,CSym 2,Semi])
  , ((lexer "max := 100;") == [VSym "max",AssignOp,CSym 100,Semi])
  , ((lexer "acc := acc * c;") == [VSym "acc",AssignOp,VSym "acc",BOp MulOp,VSym "c",Semi])
  , ((lexer "return sum;") == [Keyword ReturnK,VSym "sum",Semi])
  , ((lexer "if (n==2) then return 1;") == [Keyword IfK,LPar,VSym "n",BOp EqOp,CSym 2,RPar,Keyword ThenK,Keyword ReturnK,CSym 1,Semi])
  , ((lexer "if (n % 2 == 0) then return 0;") == [Keyword IfK,LPar,VSym "n",BOp ModOp,CSym 2,BOp EqOp,CSym 0,RPar,Keyword ThenK,Keyword ReturnK,CSym 0,Semi])
  , ((lexer "while c <= fib - 1") == [Keyword WhileK,VSym "c",BOp LteOp,VSym "fib",BOp SubOp,CSym 1])
  , ((lexer "while ! (fact <= c) {  c := c+1;   acc := acc * c; }") == [Keyword WhileK,NotOp,LPar,VSym "fact",BOp LteOp,VSym "c",RPar,LBra,VSym "c",AssignOp,VSym "c",BOp AddOp,CSym 1,Semi,VSym "acc",AssignOp,VSym "acc",BOp MulOp,VSym "c",Semi,RBra])
  , ((lexer "c:= c+1; z:= x+y; x:=y; y:=z;") == [VSym "c",AssignOp,VSym "c",BOp AddOp,CSym 1,Semi,VSym "z",AssignOp,VSym "x",BOp AddOp,VSym "y",Semi,VSym "x",AssignOp,VSym "y",Semi,VSym "y",AssignOp,VSym "z",Semi])
  , ((sr [] [VSym "sum",AssignOp,VSym "sum",BOp AddOp,VSym "y",Semi]) == [PI (Assign "sum" (Add (Var "sum") (Var "y")))])
  , ((sr [] [VSym "i",AssignOp,VSym "i",BOp AddOp,CSym 2,Semi]) == [PI (Assign "i" (Add (Var "i") (Num 2)))])
  , ((sr [] [VSym "max",AssignOp,CSym 100,Semi]) == [PI (Assign "max" (Num 100))])
  , ((sr [] [VSym "acc",AssignOp,VSym "acc",BOp MulOp,VSym "c",Semi]) == [PI (Assign "acc" (Mul (Var "acc") (Var "c")))])
  , ((sr [] [Keyword ReturnK,VSym "sum",Semi]) == [PI (Return (Var "sum"))])
  , ((sr [] [Keyword IfK,LPar,VSym "n",BOp EqOp,CSym 2,RPar,Keyword ThenK,Keyword ReturnK,CSym 1,Semi]) == [PI (IfThen (Eq (Var "n") (Num 2)) (Return (Num 1)))])
  , ((sr [] [Keyword IfK,LPar,VSym "n",BOp ModOp,CSym 2,BOp EqOp,CSym 0,RPar,Keyword ThenK,Keyword ReturnK,CSym 0,Semi]) == [PI (IfThen (Eq (Mod (Var "n") (Num 2)) (Num 0)) (Return (Num 0)))])
  , ((sr [] [Keyword WhileK,VSym "c",BOp LteOp,VSym "fib",BOp SubOp,CSym 1]) == [PB (Lte (Var "c") (Sub (Var "fib") (Num 1))),Keyword WhileK])
  , ((sr [] [Keyword WhileK,NotOp,LPar,VSym "fact",BOp LteOp,VSym "c",RPar,LBra,VSym "c",AssignOp,VSym "c",BOp AddOp,CSym 1,Semi,VSym "acc",AssignOp,VSym "acc",BOp MulOp,VSym "c",Semi,RBra]) == [PI (While (Not (Lte (Var "fact") (Var "c"))) (Do [Assign "c" (Add (Var "c") (Num 1)),Assign "acc" (Mul (Var "acc") (Var "c"))]))])
  , ((sr [] [VSym "c",AssignOp,VSym "c",BOp AddOp,CSym 1,Semi,VSym "z",AssignOp,VSym "x",BOp AddOp,VSym "y",Semi,VSym "x",AssignOp,VSym "y",Semi,VSym "y",AssignOp,VSym "z",Semi]) == [PI (Assign "y" (Var "z")),PI (Assign "x" (Var "y")),PI (Assign "z" (Add (Var "x") (Var "y"))),PI (Assign "c" (Add (Var "c") (Num 1)))])
  , ((readProg [VSym "sum",AssignOp,VSym "sum",BOp AddOp,VSym "y",Semi]) == Left [Assign "sum" (Add (Var "sum") (Var "y"))])
  , ((readProg [VSym "i",AssignOp,VSym "i",BOp AddOp,CSym 2,Semi]) == Left [Assign "i" (Add (Var "i") (Num 2))])
  , ((readProg [VSym "max",AssignOp,CSym 100,Semi]) == Left [Assign "max" (Num 100)])
  , ((readProg [VSym "acc",AssignOp,VSym "acc",BOp MulOp,VSym "c",Semi]) == Left [Assign "acc" (Mul (Var "acc") (Var "c"))])
  , ((readProg [Keyword ReturnK,VSym "sum",Semi]) == Left [Return (Var "sum")])
  , ((readProg [Keyword IfK,LPar,VSym "n",BOp EqOp,CSym 2,RPar,Keyword ThenK,Keyword ReturnK,CSym 1,Semi]) == Left [IfThen (Eq (Var "n") (Num 2)) (Return (Num 1))])
  , ((readProg [Keyword IfK,LPar,VSym "n",BOp ModOp,CSym 2,BOp EqOp,CSym 0,RPar,Keyword ThenK,Keyword ReturnK,CSym 0,Semi]) == Left [IfThen (Eq (Mod (Var "n") (Num 2)) (Num 0)) (Return (Num 0))])
  , ((readProg [Keyword WhileK,VSym "c",BOp LteOp,VSym "fib",BOp SubOp,CSym 1]) == Right "Parse error: [RBra,PB (Lte (Var \"c\") (Sub (Var \"fib\") (Num 1))),Keyword WhileK,Block []]")
  , ((readProg [Keyword WhileK,NotOp,LPar,VSym "fact",BOp LteOp,VSym "c",RPar,LBra,VSym "c",AssignOp,VSym "c",BOp AddOp,CSym 1,Semi,VSym "acc",AssignOp,VSym "acc",BOp MulOp,VSym "c",Semi,RBra]) == Left [While (Not (Lte (Var "fact") (Var "c"))) (Do [Assign "c" (Add (Var "c") (Num 1)),Assign "acc" (Mul (Var "acc") (Var "c"))])])
  , ((readProg [VSym "c",AssignOp,VSym "c",BOp AddOp,CSym 1,Semi,VSym "z",AssignOp,VSym "x",BOp AddOp,VSym "y",Semi,VSym "x",AssignOp,VSym "y",Semi,VSym "y",AssignOp,VSym "z",Semi]) == Left [Assign "c" (Add (Var "c") (Num 1)),Assign "z" (Add (Var "x") (Var "y")),Assign "x" (Var "y"),Assign "y" (Var "z")])
  , ((evala env1 (Add (Var "sum") (Var "y"))) == 13)
  , ((evala env1 (Add (Var "i") (Num 2))) == 7)
  , ((evala env1 (Mul (Var "acc") (Var "c"))) == 3)
  , ((evala env1 (Add (Var "c") (Num 1))) == 4)
  , ((evala env1 (Mod (Var "n") (Num 2))) == 0)
  , ((evala env2 (Add (Var "sum") (Var "y"))) == 120)
  , ((evala env2 (Add (Var "i") (Num 2))) == 7)
  , ((evala env2 (Mul (Var "acc") (Var "c"))) == 40)
  , ((evala env2 (Add (Var "c") (Num 1))) == 5)
  , ((evala env2 (Mod (Var "n") (Num 2))) == 1)
  , ((evalb env1 (Eq (Var "n") (Num 2))) == True)
  , ((evalb env1 (Eq (Mod (Var "n") (Num 2)) (Num 0))) == True)
  , ((evalb env1 (Not (Lte (Var "sum") (Var "c")))) == True)
  , ((evalb env1 (Not (Gte (Var "sum") (Var "c")))) == False)
  , ((evalb env1 (Lte (Var "c") (Sub (Var "n") (Num 1)))) == False)
  , ((evalb env2 (Eq (Var "n") (Num 2))) == False)
  , ((evalb env2 (Eq (Mod (Var "n") (Num 2)) (Num 0))) == False)
  , ((evalb env2 (Not (Lte (Var "sum") (Var "c")))) == True)
  , ((evalb env2 (Not (Gte (Var "sum") (Var "c")))) == False)
  , ((evalb env2 (Lte (Var "c") (Sub (Var "n") (Num 1)))) == True)
  , ((exec (Assign "fact" (Num 5)) []) == [("fact",5)])
  , ((exec (Assign "acc" (Num 1)) [("fact",5)]) == [("fact",5),("acc",1)])
  , ((exec (Assign "c" (Num 1)) [("fact",5),("acc",1)]) == [("fact",5),("acc",1),("c",1)])
  , ((exec (While (Not (Lte (Var "fact") (Var "c"))) (Do [Assign "c" (Add (Var "c") (Num 1)),Assign "acc" (Mul (Var "acc") (Var "c"))])) [("fact",5),("acc",1),("c",1)]) == [("fact",5),("acc",120),("c",5)])
  , ((exec (Return (Var "acc")) [("fact",5),("acc",120),("c",5)]) == [("",120)])
  , ((execList [Assign "c" (Add (Var "c") (Num 1)),Assign "acc" (Mul (Var "acc") (Var "c"))] [("fact",5),("acc",1),("c",1)]) == [("fact",5),("acc",2),("c",2)])
  , ((execList [Assign "c" (Add (Var "c") (Num 1)),Assign "acc" (Mul (Var "acc") (Var "c"))] [("fact",5),("acc",2),("c",2)]) == [("fact",5),("acc",6),("c",3)])
  , ((execList [Assign "c" (Add (Var "c") (Num 1)),Assign "acc" (Mul (Var "acc") (Var "c"))] [("fact",5),("acc",6),("c",3)]) == [("fact",5),("acc",24),("c",4)])
  , ((execList [Assign "c" (Add (Var "c") (Num 1)),Assign "acc" (Mul (Var "acc") (Var "c"))] [("fact",5),("acc",24),("c",4)]) == [("fact",5),("acc",120),("c",5)])
  , ((execList [Assign "fact" (Num 5),Assign "acc" (Num 1),Assign "c" (Num 1),While (Not (Lte (Var "fact") (Var "c"))) (Do [Assign "c" (Add (Var "c") (Num 1)),Assign "acc" (Mul (Var "acc") (Var "c"))]),Return (Var "acc")] []) == [("",120)])
  ]

main = do
  putStrLn $ show (length (filter id tests)) ++ '/' : show (length tests)
  let zipped = zip tests testLinesString
  sequence (map (print . snd) (filter (not . fst) zipped))
